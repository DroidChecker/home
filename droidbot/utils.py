import os
import re
import functools
from datetime import datetime
import time

# logcat regex, which will match the log message generated by `adb logcat -v threadtime`
LOGCAT_THREADTIME_RE = re.compile(
    '^(?P<date>\S+)\s+(?P<time>\S+)\s+(?P<pid>[0-9]+)\s+(?P<tid>[0-9]+)\s+'
    '(?P<level>[VDIWEFS])\s+(?P<tag>[^:]*):\s+(?P<content>.*)$'
)


def lazy_property(func):
    attribute = '_lazy_' + func.__name__

    @property
    @functools.wraps(func)
    def wrapper(self):
        if not hasattr(self, attribute):
            setattr(self, attribute, func(self))
        return getattr(self, attribute)

    return wrapper


def parse_log(log_msg):
    """
    parse a logcat message
    the log should be in threadtime format
    @param log_msg:
    @return:
    """
    m = LOGCAT_THREADTIME_RE.match(log_msg)
    if not m:
        return None
    log_dict = {}
    date = m.group('date')
    time = m.group('time')
    log_dict['pid'] = m.group('pid')
    log_dict['tid'] = m.group('tid')
    log_dict['level'] = m.group('level')
    log_dict['tag'] = m.group('tag')
    log_dict['content'] = m.group('content')
    datetime_str = "%s-%s %s" % (datetime.today().year, date, time)
    log_dict['datetime'] = datetime.strptime(datetime_str, "%Y-%m-%d %H:%M:%S.%f")

    return log_dict


def get_available_devices():
    """
    Get a list of device serials connected via adb
    :return: list of str, each str is a device serial number
    """
    import subprocess

    r = subprocess.check_output(["adb", "devices"])
    if not isinstance(r, str):
        r = r.decode()
    devices = []
    for line in r.splitlines():
        segs = line.strip().split()
        if len(segs) == 2 and segs[1] == "device":
            devices.append(segs[0])
    return devices


def weighted_choice(choices):
    import random

    total = sum(choices[c] for c in list(choices.keys()))
    r = random.uniform(0, total)
    upto = 0
    for c in list(choices.keys()):
        if upto + choices[c] > r:
            return c
        upto += choices[c]


def safe_re_match(regex, content):
    if not regex or not content:
        return None
    else:
        return regex.match(content)


def md5(input_str):
    import hashlib

    return hashlib.md5(input_str.encode('utf-8')).hexdigest()


def safe_get_dict(view_dict, key, default=None):
    return view_dict[key] if (key in view_dict) else default


def generate_report(img_path, html_path, run_count):
    '''Generate report for the test based on the executed events'''
    line_list = []
    f_html = open(
        os.path.join(html_path, str(run_count) + "_trace.html"), 'w', encoding='utf-8'
    )
    f_style = open("droidbot/resources/style/style.html", 'r', encoding='utf-8')
    img_list = os.listdir(img_path)
    sorted_img_list = sorted(
        img_list, key=lambda x: os.path.getmtime(os.path.join(img_path, x))
    )
    new_str = "<ul id=\"menu\">" + '\n'
    for img_file in sorted_img_list:
        if ".png" in img_file:
            num_end = img_file.find(".png")
            num_start = img_file.find("_")
            state_num = 1
            action = img_file[num_start + 1 : num_end]
            if img_path == html_path:
                line = (
                    "      <li><img src=\""
                    + img_file
                    + "\" class=\"img\"><p>"
                    + action
                    + "</p></li>"
                    + '\n'
                )
            else:
                line = (
                    "      <li><img src=\""
                    + "../"
                    + str(run_count)
                    + "/screen/"
                    + img_file
                    + "\" class=\"img\"><p>"
                    + action
                    + "</p></li>"
                    + '\n'
                )
            line_list.append((float(state_num), line))
    # line_list.sort()
    for item in line_list:
        new_str = new_str + item[1]
    new_str = new_str + "   </ul>"
    old_str = "<ul id=\"menu\"></ul>"
    for line in f_style:
        f_html.write(re.sub(old_str, new_str, line))

class Time(object):
    def __init__(self):
        self.start_time = time.time()

    def get_time_duration(self):
        return str(int(time.time() - self.start_time))
